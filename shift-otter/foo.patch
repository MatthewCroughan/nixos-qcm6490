From e4e350c0e154bc03a8580e4804c513e015ae732b Mon Sep 17 00:00:00 2001
From: shinyquagsire23 <mtinc2@gmail.com>
Date: Wed, 16 Apr 2025 23:32:03 -0600
Subject: [PATCH] ufs_qcom: Add support for low-power initialization for boards
 with uncertain PMIC accessibility

---
 drivers/ufs/Kconfig    | 12 ++++++++++++
 drivers/ufs/ufs-qcom.c | 36 ++++++++++++++++++++++++++++++++++++
 drivers/ufs/ufs.c      |  2 ++
 3 files changed, 50 insertions(+)

diff --git a/drivers/ufs/Kconfig b/drivers/ufs/Kconfig
index b08ca08b07c..cfc4e36e1ee 100644
--- a/drivers/ufs/Kconfig
+++ b/drivers/ufs/Kconfig
@@ -33,6 +33,18 @@ config QCOM_UFS
 	  This selects the platform driver for the UFS host
 	  controller present on Qualcomm Snapdragon SoCs.
 
+config QCOM_UFS_FORCE_LOW_POWER_MODE
+	bool "Force low power mode for Qualcomm UFS Host Controller"
+	depends on QCOM_UFS
+        help
+	  This enables a low-power initialization sequence for the Qualcomm
+	  UFS Host Controller driver.
+
+	  If clocks or power are not expected to be fully initialized yet,
+	  or cannot be initialized, say Y here.
+
+	  If unsure, say N.
+
 config TI_J721E_UFS
 	bool "Glue Layer driver for UFS on TI J721E devices"
 	help
diff --git a/drivers/ufs/ufs-qcom.c b/drivers/ufs/ufs-qcom.c
index 8659f2ea5ee..25a49d7fead 100644
--- a/drivers/ufs/ufs-qcom.c
+++ b/drivers/ufs/ufs-qcom.c
@@ -466,6 +466,28 @@ static int ufs_qcom_set_core_clk_ctrl(struct ufs_hba *hba)
 	return ufs_qcom_set_clk_40ns_cycles(hba, cycles_in_1us);
 }
 
+static int ufs_qcom_set_core_clk_ctrl_lowpower(struct ufs_hba *hba)
+{
+	struct ufs_qcom_priv *priv = dev_get_priv(hba->dev);
+	int err;
+	u32 reg;
+
+	err = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1), &reg);
+	if (err) {
+		dev_err(hba->dev, "cfg get clk failed\n");
+		return err;
+	}
+
+	// no clue what this bitflag is, PBL sets it though.
+	err = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_VS_CONFIG_REG1), reg | 0x1000);
+	if (err) {
+		dev_err(hba->dev, "cfg set clk failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
 static u32 ufs_qcom_get_local_unipro_ver(struct ufs_hba *hba)
 {
 	/* HCI version 1.0 and 1.1 supports UniPro 1.41 */
@@ -488,9 +510,11 @@ static int ufs_qcom_link_startup_notify(struct ufs_hba *hba,
 
 	switch (status) {
 	case PRE_CHANGE:
+#ifndef CONFIG_QCOM_UFS_FORCE_LOW_POWER_MODE
 		err = ufs_qcom_set_core_clk_ctrl(hba);
 		if (err)
 			dev_err(hba->dev, "cfg core clk ctrl failed\n");
+
 		/*
 		 * Some UFS devices (and may be host) have issues if LCC is
 		 * enabled. So we are setting PA_Local_TX_LCC_Enable to 0
@@ -500,7 +524,19 @@ static int ufs_qcom_link_startup_notify(struct ufs_hba *hba,
 		 */
 		if (ufs_qcom_get_local_unipro_ver(hba) != UFS_UNIPRO_VER_1_41)
 			err = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_LOCAL_TX_LCC_ENABLE), 0);
+#else
+		err = ufs_qcom_set_core_clk_ctrl_lowpower(hba);
+		if (err)
+			dev_err(hba->dev, "cfg core clk ctrl failed\n");
 
+		err = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_AVAILTXDATALANES), 1);
+		if (err)
+			dev_err(hba->dev, "cfg num tx lanes failed\n");
+
+		err = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_AVAILRXDATALANES), 1);
+		if (err)
+			dev_err(hba->dev, "cfg num rx lanes failed\n");
+#endif
 		break;
 	default:
 		break;
diff --git a/drivers/ufs/ufs.c b/drivers/ufs/ufs.c
index b80da3822c3..b0017ffaaa7 100644
--- a/drivers/ufs/ufs.c
+++ b/drivers/ufs/ufs.c
@@ -1935,6 +1935,7 @@ int ufs_start(struct ufs_hba *hba)
 		return ret;
 	}
 
+#ifndef CONFIG_QCOM_UFS_FORCE_LOW_POWER_MODE
 	if (ufshcd_get_max_pwr_mode(hba)) {
 		dev_err(hba->dev,
 			"%s: Failed getting max supported power mode\n",
@@ -1951,6 +1952,7 @@ int ufs_start(struct ufs_hba *hba)
 		debug("UFS Device %s is up!\n", hba->dev->name);
 		ufshcd_print_pwr_info(hba);
 	}
+#endif
 
 	return 0;
 }
From 0b065d3f585c5b6cccb21a3169db045af565a900 Mon Sep 17 00:00:00 2001
From: shinyquagsire23 <mtinc2@gmail.com>
Date: Wed, 16 Apr 2025 23:41:59 -0600
Subject: [PATCH] phy/qmp_ufs: Align qcom ufs phy power-on with PBL's reset
 ordering

---
 drivers/phy/qcom/phy-qcom-qmp-ufs.c       | 17 +++++++++++++++--
 drivers/phy/qcom/phy-qcom-snps-femto-v2.c |  1 +
 drivers/phy/qcom/phy-qcom-usb-ss.c        |  1 +
 3 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/drivers/phy/qcom/phy-qcom-qmp-ufs.c b/drivers/phy/qcom/phy-qcom-qmp-ufs.c
index 449b9767778..55e1a4bdf79 100644
--- a/drivers/phy/qcom/phy-qcom-qmp-ufs.c
+++ b/drivers/phy/qcom/phy-qcom-qmp-ufs.c
@@ -1176,11 +1176,22 @@ static int qmp_ufs_power_on(struct phy *phy)
 	unsigned int val;
 	int ret;
 
-	/* Power down PHY */
+	ret = qmp_ufs_do_reset(qmp);
+	if (ret) {
+		dev_err(phy->dev, "qmp reset failed\n");
+		return ret;
+	}
+
+	udelay(10);
+
+	/* Hold PHY is reset while writing calib registers */
+	if (!cfg->no_pcs_sw_reset)
+		qphy_setbits(pcs, cfg->regs[QPHY_SW_RESET], SW_RESET);
+
+	/* Power up PHY */
 	qphy_setbits(pcs, cfg->regs[QPHY_PCS_POWER_DOWN_CONTROL], SW_PWRDN);
 
 	qmp_ufs_init_registers(qmp, cfg);
-
 	if (cfg->no_pcs_sw_reset) {
 		ret = qmp_ufs_do_reset(qmp);
 		if (ret) {
@@ -1193,6 +1204,8 @@ static int qmp_ufs_power_on(struct phy *phy)
 	if (!cfg->no_pcs_sw_reset)
 		qphy_clrbits(pcs, cfg->regs[QPHY_SW_RESET], SW_RESET);
 
+	udelay(50);
+
 	/* start SerDes */
 	qphy_setbits(pcs, cfg->regs[QPHY_START_CTRL], SERDES_START);
 
diff --git a/drivers/phy/qcom/phy-qcom-snps-femto-v2.c b/drivers/phy/qcom/phy-qcom-snps-femto-v2.c
index eaf708614f4..9a8dc41f6ee 100644
--- a/drivers/phy/qcom/phy-qcom-snps-femto-v2.c
+++ b/drivers/phy/qcom/phy-qcom-snps-femto-v2.c
@@ -450,6 +450,7 @@ static const struct udevice_id qcom_snps_hsphy_phy_ids[] = {
 	{ .compatible = "qcom,usb-snps-hs-7nm-phy",
 		.data = (ulong)&sc7280_snps_7nm_phy, },
 	{ .compatible = "qcom,usb-snps-femto-v2-phy" },
+	{ .compatible = "qcom,usb-hsphy-snps-femto" },
 	{}
 };
 
diff --git a/drivers/phy/qcom/phy-qcom-usb-ss.c b/drivers/phy/qcom/phy-qcom-usb-ss.c
index 270d09d883c..a9c6453740b 100644
--- a/drivers/phy/qcom/phy-qcom-usb-ss.c
+++ b/drivers/phy/qcom/phy-qcom-usb-ss.c
@@ -140,6 +140,7 @@ static struct phy_ops ssphy_ops = {
 
 static const struct udevice_id ssphy_ids[] = {
 	{ .compatible = "qcom,usb-ss-28nm-phy" },
+	{ .compatible = "qcom,usb-ssphy-qmp-dp-combo" },
 	{ }
 };
 From 663c0aeaf8f7494682f5b48391dc048908b4bff7 Mon Sep 17 00:00:00 2001
From: shinyquagsire23 <mtinc2@gmail.com>
Date: Wed, 16 Apr 2025 23:31:19 -0600
Subject: [PATCH] ufs_qcom: Fix resetting not working with link startup
 failures

---
 drivers/ufs/ufs-qcom.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/ufs/ufs-qcom.c b/drivers/ufs/ufs-qcom.c
index 843585726c7..8659f2ea5ee 100644
--- a/drivers/ufs/ufs-qcom.c
+++ b/drivers/ufs/ufs-qcom.c
@@ -243,6 +243,14 @@ static int ufs_qcom_power_up_sequence(struct ufs_hba *hba)
 		return ret;
 	}
 
+	/* power off phy, because if we are resetting everything we need the phy on count to reset */
+	ret = generic_phy_power_off(&phy);
+	if (ret) {
+		dev_err(hba->dev, "%s: phy power off failed, ret = %d\n",
+			__func__, ret);
+		goto out_disable_phy;
+	}
+
 	/* power on phy */
 	ret = generic_phy_power_on(&phy);
 	if (ret) {

